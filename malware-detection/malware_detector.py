import pandas as pd
import matplotlib.pyplot as plt
import numpy as np
import os
import copy
import time
import datetime
import warnings

from sklearn.model_selection import train_test_split # for splitting the data into train and test samples
from sklearn import tree # for decision tree models

# for model evaluation metrics
from sklearn.metrics import classification_report, confusion_matrix, plot_confusion_matrix
from sklearn.metrics import average_precision_score, precision_recall_curve, average_precision_score
from sklearn.metrics import balanced_accuracy_score, matthews_corrcoef

import plotly.express as px  # for data visualization
import plotly.graph_objects as go # for data visualization
import graphviz # for plotting decision tree graphs

from sklearn.metrics import precision_recall_curve, roc_curve, auc
from sklearn.preprocessing import label_binarize

from sklearn.model_selection import learning_curve
from sklearn.model_selection import ShuffleSplit
from sklearn.pipeline import make_pipeline

from sklearn.base import BaseEstimator, ClassifierMixin, TransformerMixin
from sklearn.utils.validation import check_X_y, check_array, check_is_fitted
from sklearn.utils.multiclass import unique_labels
from sklearn.metrics import euclidean_distances
from sklearn.preprocessing import StandardScaler
from sklearn.decomposition import PCA
from sklearn.svm import SVC
from sklearn.ensemble import RandomForestClassifier
from sklearn.multiclass import OneVsRestClassifier
from sklearn import tree
from sklearn.neighbors import KNeighborsClassifier

from xgboost.sklearn import XGBClassifier
from sklearn.neural_network import MLPClassifier

from sklearn.multiclass import OneVsRestClassifier

import xgboost as xgb

from malware_classifier import MalwareClassifier
from malware_transformer import MalwareTransormer
from outils import Outils

class Malware_Detector:
    def __init__(self, path, target_classes, malware_features, size=1., classification_level=None, preprocessing=True, random_state=23, test_size=0.3, verbose=0, epochs=100, prediction='mean'):
        self.path = path

        self.random_state_ = random_state
        self.test_size_ = test_size
        self.verbose_ = verbose
        self.epochs_ = epochs

        if (prediction != 'max') and (prediction != 'mean'):
            warnings.warn('[Malware Detector] Warning: prediction should be `mean` or `max`. `mean` was selected by default.')
            prediction = 'mean'
        self.prediction_ = prediction

        if not isinstance(target_classes, dict):
            warnings.warn('[Malware Detector] ERROR: `target_classes` should be a dictionary')
            raise SystemExit(1)
        self.target_classes_ = target_classes

        if isinstance(malware_features, list):
            if np.any(list(map(lambda x: not isinstance(x, str), malware_features))):
                warnings.warn('[Malware Detector] ERROR: `malware_features` should be a list of str or str')
                raise SystemExit(1)
            self.malware_features_ = malware_features
        elif isinstance(malware_features, str):
            self.malware_features_ = [malware_features]
        else:
            warnings.warn('[Malware Detector] ERROR: `malware_features` should be a list of str or str')
            raise SystemExit(1)
          
        if (len(self.malware_features_) == 0) or (np.all(list(map(lambda x: x == '', self.malware_features_)))):
            warnings.warn('[Malware Detector] ERROR: no `malware_features` was specified')
            raise SystemExit(1)

        if classification_level == None:
            classification_level = len(self.malware_features_) - 1
        elif classification_level < 0:
            warnings.warn('[Malware Detector] Warning: `classification_level` should be >= 0. The first level of classification was chosen by default')
            classification_level = 0
        elif classification_level >= len(self.malware_features_):
            warnings.warn('[Malware Detector] Warning: `classification_level` should be < len(malware_features). The last level of classification was chosen by default')
            classification_level = len(self.malware_features_) - 1
        self.classification_level_ = classification_level

        self.feature_classes_ = {}
        classes_dict = self.extract_sub_dict_(self.target_classes_)
        self.models_, self.nb_sub_classes_, self.class_code_ = self.extract_models_nb_classes_(classes_dict, self.malware_features_[0])

        self.load_prepare_data_(size)

        self.outils_ = Outils()
        self.classifier_ = MalwareClassifier(self.outils_, self.target_classes_, self.class_code_, self.models_, self.malware_features_, self.feature_classes_, self.nb_classes_, self.nb_sub_classes_, random_state=random_state, verbose=verbose, epochs=epochs, prediction=prediction)
        if preprocessing:
            self.transformer_ = MalwareTransormer(features=self.feature_names_, malware_features=self.malware_features_)
            self.pipeline_ = make_pipeline(self.transformer_, self.classifier_)
        else:
            self.pipeline_ = self.classifier_

    def extract_sub_dict_(self, dict_, level=0):
        sub_dict = copy.deepcopy(dict_)
        for key, value in dict_.items():
            if (level == self.classification_level_) and (key != 'model'):
                sub_dict[key] = key
            elif isinstance(value, dict):
                sub_dict[key] = self.extract_sub_dict_(value, level+1)

        return sub_dict

    def update_dict(self, dict_1: dict, dict_2: dict):
        keys_1 = list(dict_1.keys())
        for key in dict_2.keys():
            if key in keys_1:
                dict_1[key].update(dict_2[key])
            else:
                dict_1[key] = dict_2[key]

        return dict_1

    def extract_models_nb_classes_(self, dictionary: dict, super_key, with_model_name=True, level=0, nb_leaves=0, nb_siblings=0):      
        models = {}
        nb_sub_classes = {}
        class_codes = {}
        keys =list(dictionary.keys())

        if 'model' in keys:
            if with_model_name:
                if isinstance(dictionary['model'], list):
                    if len(dictionary['model']) == 0:
                        model_names = ['']
                    elif np.any(list(map(lambda x: not isinstance(x, str), dictionary['model']))):
                        warnings.warn('[Malware Detector] ERROR: `malware_name` for `{}` should be a list of str or str'.format(super_key))
                        raise SystemExit(1)
                    elif np.all(list(map(lambda x: x == '', dictionary['model']))):
                        model_names = ['']
                    else:
                        model_names = [model_name for model_name in dictionary['model'] if model_name != '']
                elif isinstance(dictionary['model'], str):
                    model_names = [dictionary['model']]
                else:
                    warnings.warn('[Malware Detector] ERROR: `model_name` should be a string')
                    raise SystemExit(1)
                models[level] = {super_key: model_names}
            else:
                models[level] = {super_key: []}
            nb_sub_classes[super_key + '_' + str(level)] = len(dictionary) - 1
        else:
            with_model_name = False
            models[level] = {super_key: []}
            nb_sub_classes[super_key + '_' + str(level)] = len(dictionary)
        
        if level == self.classification_level_:
            with_model_name = False

        class_codes[super_key + '_' + str(level)] = {}
        i = 0
        nb_next_siblings = 0
        nb_next_leaves = nb_leaves
        if nb_siblings == 0:
            self.feature_classes_[level] = {}

        for key, value in dictionary.items():
            if key != 'model':
                class_codes[super_key + '_' + str(level)][key] = i + nb_leaves + nb_siblings
                self.feature_classes_[level][key] = i + nb_leaves + nb_siblings
                i += 1
                if isinstance(value, dict):
                    sub_models, sub_classes, next_class_codes = self.extract_models_nb_classes_(value, key, with_model_name=with_model_name, level=level+1, nb_leaves=nb_next_leaves, nb_siblings=nb_next_siblings)
                    models = self.update_dict(models, sub_models)
                    nb_sub_classes.update(sub_classes)
                    class_codes.update(next_class_codes)
                    nb_next_siblings += len(next_class_codes[key + '_' + str(level+1)])
                else:
                    if level < self.classification_level_:
                        nb_next_leaves += 1

        return models, nb_sub_classes, class_codes

    def order_dict_(self, dictionary: dict):
        list(map(list, np.array(list(dictionary.values()))[:,0]))

    def get_useless_columns_(self, data):
        numeric_columns = data._get_numeric_data().columns.tolist()
        numeric_unique_values = dict(map(lambda x: (x, data[x].unique()), numeric_columns))

        useless_columns = []
        for key, value in numeric_unique_values.items():
            if len(value) == 1:
                useless_columns.append(key)

        return useless_columns
        
    def load_prepare_data_(self, size):
        data = pd.read_csv(self.path)
        useless_columns = self.get_useless_columns_(data)
        for useless_col in useless_columns:
            del data[useless_col]

        for feature in self.malware_features_:
            if feature not in data.columns.values:
                warnings.warn('[Malware Detector] ERROR: `malware_features` -> `data` doesn\'t have a column called {}'.format(feature))
                raise SystemExit(1)

        if size <= 0:
            warnings.warn('[Malware Detector] ERROR: `size` should be > 0')
            raise SystemExit(1)
        elif size > 1:
            if not isinstance(size, int):
                warnings.warn('[Malware Detector] ERROR: `size` should be an interger > 1 or a float <= 1')
                raise SystemExit(1)
            elif size > len(data):
                warnings.warn('[Malware Detector] Warning: `size` exceeds size of the data in `path`. The whole data was selected by default.')
                size = 1.
        
        if size == 1:
            data = data.sample(frac=1, random_state=self.random_state_)
        else:
            data, _ = train_test_split(data, train_size=size, shuffle=True, random_state=self.random_state_)

        self.X = data.drop(self.malware_features_, axis=1)
        self.feature_names_ = self.X.columns.values

        self.malware_features_ = self.malware_features_[:self.classification_level_+1] 
        for feature in self.malware_features_[:-1]:
            self.X[feature] = data[feature]
        self.y = data[self.malware_features_[-1]]
        classes = self.y.unique()
        self.nb_classes_ = len(classes)
        """self.class_code_ = {}
        for level, feature in enumerate(self.malware_features_):
            self.class_code_[feature] = {}

            if feature == self.malware_features_[-1]:
                classes = self.y.unique()
            else:
                classes = self.X[feature].unique()
            
            for i, target_class in enumerate(classes):
                self.class_code_[feature][target_class] = i
            
            if feature == self.malware_features_[-1]:
                self.y = self.y.map(self.class_code_[feature]).astype(int)
            else:
                self.X[feature] = self.X[feature].map(self.class_code_[feature]).astype(int)"""
        ## encoding
        self.encoding_ = {}
        for level, feature in enumerate(self.malware_features_):
            classes = {}
            for i in range(level + 1):
                classes.update({v:k for k, v in self.feature_classes_[i].items()})
            classes = {v:k for k, v in classes.items()}

            self.encoding_[feature] = classes
            if feature == self.malware_features_[-1]:
                self.y = self.y.map(classes).astype(int)
            else:
                self.X[feature] = self.X[feature].map(classes).astype(int)
        
        self.X_train, self.X_test, self.y_train, self.y_test = train_test_split(self.X, self.y, stratify=self.y, random_state=self.random_state_, test_size=self.test_size_)

    def fit(self):
        self.pipeline_.fit(self.X_train, self.y_train)            

    def predict(self):
        predicted_codes = self.pipeline_.predict(self.X_train)
        code_to_class = dict((v,k) for k,v in self.encoding_[self.malware_features_[-1]].items())
        predicted_classes = pd.Series(predicted_codes).map(code_to_class).values
        return predicted_classes

    def report_(self):
        target_names = {}
        for level in range(self.classification_level_ + 1):
            target_names.update({v:k for k, v in self.feature_classes_[level].items()})
        target_names = list(target_names.values())
        self.outils_.performance_report(self.pipeline_, self.X_test, self.y_test, target_names=target_names)

        if self.verbose_ != 0:
            # Cross validation with 50 iterations to get smoother mean test and train
            # score curves, each time with 20% data randomly selected as a validation set.
            cv = ShuffleSplit(n_splits=50, test_size=self.test_size_, random_state=self.random_state_)
            self.outils_.plot_learning_curve(
                estimator=self.pipeline_,
                title="Meta Model Learning Curves",
                X=self.X,
                y=self.y,
                ylim=None,#(0.4, 1.01),
                cv=cv,
                n_jobs=4,
                scoring="accuracy",
            )