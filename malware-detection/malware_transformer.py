import pandas as pd
import matplotlib.pyplot as plt
import numpy as np
import os
import copy
import time
import datetime
import warnings

from sklearn.model_selection import train_test_split # for splitting the data into train and test samples
from sklearn import tree # for decision tree models

# for model evaluation metrics
from sklearn.metrics import classification_report, confusion_matrix, plot_confusion_matrix
from sklearn.metrics import average_precision_score, precision_recall_curve, average_precision_score
from sklearn.metrics import balanced_accuracy_score, matthews_corrcoef

import plotly.express as px  # for data visualization
import plotly.graph_objects as go # for data visualization
import graphviz # for plotting decision tree graphs

from sklearn.metrics import precision_recall_curve, roc_curve, auc
from sklearn.preprocessing import label_binarize

from sklearn.model_selection import learning_curve
from sklearn.model_selection import ShuffleSplit
from sklearn.pipeline import make_pipeline

from sklearn.base import BaseEstimator, ClassifierMixin, TransformerMixin
from sklearn.utils.validation import check_X_y, check_array, check_is_fitted
from sklearn.utils.multiclass import unique_labels
from sklearn.metrics import euclidean_distances
from sklearn.preprocessing import StandardScaler
from sklearn.decomposition import PCA
from sklearn.svm import SVC
from sklearn.ensemble import RandomForestClassifier
from sklearn.multiclass import OneVsRestClassifier
from sklearn import tree
from sklearn.neighbors import KNeighborsClassifier

from xgboost.sklearn import XGBClassifier
from sklearn.neural_network import MLPClassifier

from sklearn.multiclass import OneVsRestClassifier

import xgboost as xgb

from numpy.core.memmap import ndarray
class MalwareTransormer(TransformerMixin, BaseEstimator):
    """ 
    Parameters
    ----------
    demo_param : str, default='demo'
        A parameter used for demonstation of how to pass and store paramters.
    Attributes
    ----------
    n_features_ : int
        The number of features of the data passed to :meth:`fit`.
    """
    def __init__(self, features, malware_features, demo_param='demo'):
        self.demo_param = demo_param
        self.scaler_ = StandardScaler()
        self.pca_ = PCA(.95)
        self.is_fitted_ = False
        self.feature_names_ = features
        self.malware_features_ = malware_features

    def extract_X_(self, X):
        if isinstance(X, pd.DataFrame):
            X_ = X.copy()
            if len(self.malware_features_) > 1:
                X_ = X_.drop(self.malware_features_[:-1], axis=1)
        elif isinstance(X, list) or isinstance(X, ndarray):
            X_ = np.copy(X)
            if len(self.malware_features_) > 1:
                X_ = X_[:, :-len(self.malware_features_)+1]
        else:
            warnings.warn('ERROR: `X` should be pandas.DataFrame, list or ndarray')
            raise SystemExit(1)
        return X_

    def add_malware_features_(self, X, X_):
        if isinstance(X_, pd.DataFrame):
            X_res = X_.copy().to_numpy()
        elif isinstance(X_, list) or isinstance(X_, ndarray):
            X_res = np.copy(X_)
        else:
            warnings.warn('ERROR: `X` should be pandas.DataFrame, list or ndarray')
            raise SystemExit(1)

        if isinstance(X, pd.DataFrame):
            X_np = X.copy().to_numpy()
        elif isinstance(X, list) or isinstance(X, ndarray):
            X_np = np.copy(X_)
        else:
            warnings.warn('ERROR: `X` should be pandas.DataFrame, list or ndarray')
            raise SystemExit(1)

        if len(self.malware_features_) > 1:
            X_res = np.append(X_res, X_np[:, -len(self.malware_features_)+1:], axis=1)
        
        return X_res

    def fit(self, X, y=None):
        """A reference implementation of a fitting function for a transformer.
        Parameters
        ----------
        X : {array-like, sparse matrix}, shape (n_samples, n_features)
            The training input samples.
        y : None
            There is no need of a target in a transformer, yet the pipeline API
            requires this parameter.
        Returns
        -------
        self : object
            Returns self.
        """
        
        X_ = self.extract_X_(X)
        X_ = check_array(X_, accept_sparse=True)

        self.n_features_ = X_.shape[1]

        self.scaler_.fit(X_)

        X_scaled = pd.DataFrame(self.scaler_.transform(X_), columns=self.feature_names_)

        # Feature Extraction
        self.pca_.fit(X_scaled)

        self.is_fitted_ = True

        # Return the transformer
        return self

    def transform(self, X):
        """ A reference implementation of a transform function.
        Parameters
        ----------
        X : {array-like, sparse-matrix}, shape (n_samples, n_features)
            The input samples.
        Returns
        -------
        X_transformed : array, shape (n_samples, n_features)
            The array containing the element-wise square roots of the values
            in ``X``.
        """
        # Check is fit had been called
        check_is_fitted(self, 'is_fitted_')

        # Input validation
        X_ = self.extract_X_(X)
        X_ = check_array(X_, accept_sparse=True)

        # Check that the input is of the same shape as the one passed
        # during fit.
        if X_.shape[1] != self.n_features_:
            raise ValueError('Shape of input is different from what was seen'
                             'in `fit`')
            
        # Data Scalling
        X_scaled = pd.DataFrame(self.scaler_.transform(X_), columns=self.feature_names_)

        # Feature Extraction
        principalComponents = self.pca_.transform(X_scaled)
        new_columns = ['PC{}'.format(i+1) for i in range(self.pca_.n_components_)]
        X_transformed = pd.DataFrame(data=principalComponents, columns=new_columns)
        
        X_transformed = self.add_malware_features_(X, X_transformed)

        return X_transformed